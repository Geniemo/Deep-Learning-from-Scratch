import numpy as np

# numpy 배열을 만들 때는 np.array() 라는 메소드를 이용한다.
# 이 메소드는 리스트를 인수로 받아 numpy가 제공하는 특수한 형태의 배열 numpy.ndarray를 반환한다.
x = np.array([1.0, 2.0, 3.0])
print(x)
print(type(x))

# 넘파이 배열로 산술 연산을 하려면 두 배열의 원소 수가 같아야 한다.
# 원소 수가 다르면 오류가 난다.
# 두 원소 수가 같다면 연산은 각 원소에 대해서 행해진다.
y = np.array([2.0, 4.0, 6.0])
print(x + y)
print(x - y)
print(x * y)
print(x / y)

# 넘파이 배열은 원소별 계산 뿐 아니라 넘파이 배열과 수치 하나(스칼라값)의 조합으로 된 연산도 가능하다.
# 이 경우 스칼라값과의 계산이 원소별로 한 번씩 이루어진다. 이러한 기능을 브로드캐스트 라고 한다.
print(x / 2.0)

# 넘파이는 1차원 배열 뿐 아니라 다차원 배열도 작성 가능하다.
# 행렬의 형상(행렬을 포함한 N차원 배열에서 그 배열의 각 차원의 크기)는 shape으로,
# 행렬에 담긴 원소의 자료형은 dtype으로 알 수 있다.
x = np.array([[1, 2], [3, 4]])
print(x)
print(x.shape)
print(x.dtype)

# 형상이 같은 행렬끼리면 행렬의 산술 연산도 대응하는 원소별로 계산된다.
# 스칼라값에 대한 계산도 브로드캐스트 기능이 작용한다.
y = np.array([[3, 0], [0, 6]])
print(x * y)
print(x * 10)

# 넘파이에서는 형상이 다른 배열끼리도 계산할 수 있다.
# 앞의 예에서는 2 * 2행렬인 x 에 10스칼라값 10을 곱했는데,
# 이 때 10이라는 스칼라값이 2 * 2 행렬로 확대([[10, 10], [10, 10]])되어 계산이 이뤄진다.
# 이러한 기능을 브로드캐스트 라고 한다.

y = np.array([10, 20])
print(x * y)
# 위의 예에서도 y가 x와 똑같은 형상으로 변형된 후 계산이 이루어진다.
# [[10, 20], [10, 20]] 으로 변형된다.

# 넘파이 배열의 인덱스도 0부터 시작하고, 각 원소에 접근하려면 다음과 같이 한다.
x = np.array([[1, 2], [3, 4], [5, 6]])
print(x[0])
print(x[0][1])

# 다음과 같이 for문으로 접근도 가능하다.
for r in x:
    print(r)

# 이런 방법 외에도 인득스를 배열로 지정해 한 번에 여러 원소에 접근할 수도 있다.
x = x.flatten()  # x를 1차원 배열로 변경 [1, 2, 3, 4, 5, 6]
print(x)
print(x[np.array([0, 2, 4])])  # 인덱스가 0, 2, 4인 원소 얻기

# 이러한 기법을 응용하면 특정 조건을 만족하는 원소만 얻을 수 있다.
# 예를 들어, 다음과 같이 x에서 값이 3보다 큰 원소들만 구할 수 있다.
print(x > 3)  # 넘파이 배열에 부등호 연산자를 사용한 결과는 bool 배열이다.
print(x[x > 3])  # 여기서 bool 배열을 이용해 값이 True인 원소만 꺼내고 있다.
